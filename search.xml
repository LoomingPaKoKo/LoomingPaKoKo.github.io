<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vite 打包优化之手动分包</title>
      <link href="/2023/09/28/vite%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E4%B9%8B%E6%89%8B%E5%8A%A8%E5%88%86%E5%8C%85/"/>
      <url>/2023/09/28/vite%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E4%B9%8B%E6%89%8B%E5%8A%A8%E5%88%86%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="vite-打包优化之手动分包"><a href="#vite-打包优化之手动分包" class="headerlink" title="vite 打包优化之手动分包"></a>vite 打包优化之手动分包</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先，我们要清楚为什么需要对工程进行分包。</p><p>浏览器在每次访问页面时，会根据<strong>文件指纹</strong>判断是从服务器下载还是读取缓存。<br>若每次对项目打包，都将所有内容打包在一起，例如经常更改的页面模块和类似于lodash这些不常更新的库，那么每次打包完毕后都会产生一个新的文件指纹。</p><p>用户浏览器在访问时则会因为文件指纹不同从而去服务器下载新的资源。</p><p>在这个过程中，那些不常更改、稳定的库，也会被重新下载一次。这样就加大了用户等待的时间。所以我们需要对工程进行分包进而优化浏览器加载时间。</p><h5 id="什么是文件指纹"><a href="#什么是文件指纹" class="headerlink" title="什么是文件指纹"></a>什么是文件指纹</h5><p>文件指纹是文件打包后输出的文件名的后缀，通常用来做一些文件的版本管理。浏览器会根据文件指纹进而做出是去服务器重新下载，还是读取本地缓存的动作。</p><h3 id="如何使用Vite做手动分包"><a href="#如何使用Vite做手动分包" class="headerlink" title="如何使用Vite做手动分包"></a>如何使用Vite做手动分包</h3><h5 id="自动分包和手动分包"><a href="#自动分包和手动分包" class="headerlink" title="自动分包和手动分包"></a>自动分包和手动分包</h5><p>在vite内，分为自动分包和手动分包。若我们使用<strong>动态导入</strong>，则会进行自动分包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="配置rollup"><a href="#配置rollup" class="headerlink" title="配置rollup"></a>配置rollup</h5><p>在vite的背后，用的是esbuild和rollup。前者负责开发环境，后者负责打包。现在我们需要影响打包结果，所以需要在vite.config.js中对<strong>rollup</strong>的<strong>manualChunks</strong>进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line"><span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line"><span class="attr">build</span>: &#123;</span><br><span class="line"><span class="attr">rollupOptions</span>: &#123;</span><br><span class="line"><span class="attr">manualChunks</span>: &#123;</span><br><span class="line"><span class="attr">lodash</span>: [ <span class="string">&#x27;lodash&#x27;</span> ],</span><br><span class="line"><span class="attr">vue</span>: [ <span class="string">&#x27;vue&#x27;</span> ]</span><br><span class="line"><span class="comment">// 当然也可以直接合并在一起</span></span><br><span class="line"><span class="comment">// xxx: [ &#x27;lodash&#x27; , &#x27;vue&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，我们也可以将manualChunks配置为一个<strong>函数</strong>，将node_modules中的内容打包在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为所传入的依赖模块的id</span></span><br><span class="line"><span class="title function_">manualChunks</span>(<span class="params">id</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(id.<span class="title function_">includes</span>(<span class="string">&#x27;node_modules&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// 返回包名，这里可以自定义</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;vendor&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述对vite的rollup进行配置后，我们将一些不会经常变动的第三方库打包在了一起。<br>这样每次在修改页面，打包部署后，用户访问时就不会从服务器下载那些打包在一起，没有更改的第三方库包，而是从浏览器读取本地缓存。从而加快了用户的访问速度。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vite </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中无限递归一定会导致栈溢出吗？</title>
      <link href="/2023/09/27/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%AF%BC%E8%87%B4%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/09/27/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%AF%BC%E8%87%B4%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><em><strong>关于栈溢出，我们通常会感觉无限递归会导致栈溢出。但是一定如此吗？</strong></em></p><hr><h3 id="什么是栈溢出"><a href="#什么是栈溢出" class="headerlink" title="什么是栈溢出"></a>什么是栈溢出</h3><p>栈是一块 <strong>内存空间</strong> ，而每一次函数调用，就相当于往内存空间内加入一个执行上下文。当这个函数没有执行完时，又调用了另一个函数（比方说自身），这个时候就又会往内存空间内加入一个执行上下文。反复如此的话，栈会被撑满，空间不够了，这就叫栈溢出。</p><p>例如下面这段代码就是个典型的无限递归场景。<br>在foo()调用结束之前又调用了foo()，因此会导致栈溢出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h3 id="什么情况下无限递归不会导致栈溢出"><a href="#什么情况下无限递归不会导致栈溢出" class="headerlink" title="什么情况下无限递归不会导致栈溢出"></a>什么情况下无限递归不会导致栈溢出</h3><p>例如下面这种情况，就不会导致栈溢出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(foo,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>在调用foo()时，往执行栈内加入一个上下文。而在该上下文执行期间，会开启一个定时器，而计时器到达之后，会再一次执行foo函数。<strong>但由于JS语言是异步的</strong>，也就是说，foo函数本身不会等待计时器结束。<br>foo()在创建完计时器后，会运行结束，随后出栈。随后计时器到达，加入事件队列，而后执行上下文，调用foo()，重复该步骤，因此栈不会溢出。</p><h4 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h4><p>若是这种情况，则会导致栈溢出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="title function_">foo</span>(),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>这是因为在开启定时器前，需要将foo()作为参数传入，所以会先执行foo()将其返回结果作为参数传入setTimeout。故变成了在计时之前调用foo()，因此会导致栈溢出。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
