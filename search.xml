<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用阿里云OSS搭建图床</title>
      <link href="/2023/10/08/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/10/08/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="利用阿里云OSS搭建图床"><a href="#利用阿里云OSS搭建图床" class="headerlink" title="利用阿里云OSS搭建图床"></a>利用阿里云OSS搭建图床</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>登录阿里云后，在产品中找到“存储对象OSS”，点击开通（开通不需要费用）后进入控制台。<br>在左侧菜单栏中点击“Bucket列表”，并创建一个新的Bucket（如下图所示）</p><blockquote><p>其中区域可以任选例如广州、深圳等地</p></blockquote><p>完成Bucket创建后，需要购买资源包。选择购买OSS资源包，地域选择中国大陆通用（前提是你创建的Bucket在中国大陆内）</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> OSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档注释</title>
      <link href="/2023/10/01/%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/"/>
      <url>/2023/10/01/%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，我们会将一些函数进行封装，而为了使日后调用这些函数的时候能更好的清楚所调用函数的参数、返回值、作用等信息，我们需要对其进行文档注释。</p><h3 id="认识文档注释"><a href="#认识文档注释" class="headerlink" title="认识文档注释"></a>认识文档注释</h3><p>文档注释说白了就是注释的一种，平常我们会为一些代码段进行注释来表明这段代码的作用。而文档注释则是为了让我们对某些封装的函数一目了然。</p><h4 id="普通的单行注释"><a href="#普通的单行注释" class="headerlink" title="普通的单行注释"></a>普通的单行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>文档注释由以下JsDoc标签组成</p><h4 id="param-参数注释"><a href="#param-参数注释" class="headerlink" title="@param 参数注释"></a>@param 参数注释</h4><p>使用@param注释来表示当前的函数或类的方法的参数。通常是由 @param + { 参数类型 } + 参数名 + 参数说明 组成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网络请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> object </span>&#125; options 配置对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> string </span>&#125; options.url 请求地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> &#x27;GET&#x27; | &#x27;POST&#x27;</span>&#125; options.method 请求方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> object </span>&#125; options.body 请求体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> object </span>&#125; options.headers 请求头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type"> Promise </span>&#125; 返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * request(options) // 返回Promise，使用then或catch得到返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">options</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite 打包优化之手动分包</title>
      <link href="/2023/09/28/vite%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E4%B9%8B%E6%89%8B%E5%8A%A8%E5%88%86%E5%8C%85/"/>
      <url>/2023/09/28/vite%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E4%B9%8B%E6%89%8B%E5%8A%A8%E5%88%86%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="vite-打包优化之手动分包"><a href="#vite-打包优化之手动分包" class="headerlink" title="vite 打包优化之手动分包"></a>vite 打包优化之手动分包</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先，我们要清楚为什么需要对工程进行分包。</p><p>浏览器在每次访问页面时，会根据<strong>文件指纹</strong>判断是从服务器下载还是读取缓存。<br>若每次对项目打包，都将所有内容打包在一起，例如经常更改的页面模块和类似于lodash这些不常更新的库，那么每次打包完毕后都会产生一个新的文件指纹。</p><p>用户浏览器在访问时则会因为文件指纹不同从而去服务器下载新的资源。</p><p>在这个过程中，那些不常更改、稳定的库，也会被重新下载一次。这样就加大了用户等待的时间。所以我们需要对工程进行分包进而优化浏览器加载时间。</p><h5 id="什么是文件指纹"><a href="#什么是文件指纹" class="headerlink" title="什么是文件指纹"></a>什么是文件指纹</h5><p>文件指纹是文件打包后输出的文件名的后缀，通常用来做一些文件的版本管理。浏览器会根据文件指纹进而做出是去服务器重新下载，还是读取本地缓存的动作。</p><h3 id="如何使用Vite做手动分包"><a href="#如何使用Vite做手动分包" class="headerlink" title="如何使用Vite做手动分包"></a>如何使用Vite做手动分包</h3><h5 id="自动分包和手动分包"><a href="#自动分包和手动分包" class="headerlink" title="自动分包和手动分包"></a>自动分包和手动分包</h5><p>在vite内，分为自动分包和手动分包。若我们使用<strong>动态导入</strong>，则会进行自动分包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="配置rollup"><a href="#配置rollup" class="headerlink" title="配置rollup"></a>配置rollup</h5><p>在vite的背后，用的是esbuild和rollup。前者负责开发环境，后者负责打包。现在我们需要影响打包结果，所以需要在vite.config.js中对<strong>rollup</strong>的<strong>manualChunks</strong>进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">        <span class="attr">manualChunks</span>: &#123;</span><br><span class="line">                <span class="attr">lodash</span>: [ <span class="string">&#x27;lodash&#x27;</span> ],</span><br><span class="line">                <span class="attr">vue</span>: [ <span class="string">&#x27;vue&#x27;</span> ]</span><br><span class="line">                <span class="comment">// 当然也可以直接合并在一起</span></span><br><span class="line">                <span class="comment">// xxx: [ &#x27;lodash&#x27; , &#x27;vue&#x27; ]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，我们也可以将manualChunks配置为一个<strong>函数</strong>，将node_modules中的内容打包在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为所传入的依赖模块的id</span></span><br><span class="line"><span class="title function_">manualChunks</span>(<span class="params">id</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(id.<span class="title function_">includes</span>(<span class="string">&#x27;node_modules&#x27;</span>))&#123;</span><br><span class="line">        <span class="comment">// 返回包名，这里可以自定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;vendor&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述对vite的rollup进行配置后，我们将一些不会经常变动的第三方库打包在了一起。<br>这样每次在修改页面，打包部署后，用户访问时就不会从服务器下载那些打包在一起，没有更改的第三方库包，而是从浏览器读取本地缓存。从而加快了用户的访问速度。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vite </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中无限递归一定会导致栈溢出吗？</title>
      <link href="/2023/09/27/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%AF%BC%E8%87%B4%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/09/27/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%AF%BC%E8%87%B4%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><em><strong>关于栈溢出，我们通常会感觉无限递归会导致栈溢出。但是一定如此吗？</strong></em></p><hr><h3 id="什么是栈溢出"><a href="#什么是栈溢出" class="headerlink" title="什么是栈溢出"></a>什么是栈溢出</h3><p>栈是一块 <strong>内存空间</strong> ，而每一次函数调用，就相当于往内存空间内加入一个执行上下文。当这个函数没有执行完时，又调用了另一个函数（比方说自身），这个时候就又会往内存空间内加入一个执行上下文。反复如此的话，栈会被撑满，空间不够了，这就叫栈溢出。</p><p>例如下面这段代码就是个典型的无限递归场景。<br>在foo()调用结束之前又调用了foo()，因此会导致栈溢出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h3 id="什么情况下无限递归不会导致栈溢出"><a href="#什么情况下无限递归不会导致栈溢出" class="headerlink" title="什么情况下无限递归不会导致栈溢出"></a>什么情况下无限递归不会导致栈溢出</h3><p>例如下面这种情况，就不会导致栈溢出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(foo,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>在调用foo()时，往执行栈内加入一个上下文。而在该上下文执行期间，会开启一个定时器，而计时器到达之后，会再一次执行foo函数。<strong>但由于JS语言是异步的</strong>，也就是说，foo函数本身不会等待计时器结束。<br>foo()在创建完计时器后，会运行结束，随后出栈。随后计时器到达，加入事件队列，而后执行上下文，调用foo()，重复该步骤，因此栈不会溢出。</p><h4 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h4><p>若是这种情况，则会导致栈溢出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="title function_">foo</span>(),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>这是因为在开启定时器前，需要将foo()作为参数传入，所以会先执行foo()将其返回结果作为参数传入setTimeout。故变成了在计时之前调用foo()，因此会导致栈溢出。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
